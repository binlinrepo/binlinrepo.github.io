---
title: CS-App 读书笔记（第二章）
layout: blog
tags: CS-APP
---

# CS-APP 读书笔记

## 摘录

### 信息存储

* **无符号**（unsigned）编码基于传统的二进制表示法，表示大于或这等于零的数字。**补码**（two's-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。**浮点数**（floating-point）编码是表示实数的科学计数法的以2为基数的版本。

* 计算机的表示法使用有限数量的位来对一个数字编码，因此，当结果太大以致不能表示时，某些运算就会溢出。
<!--more-->

* 大多数计算机使用8位的块，或者 **字节**（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的数组，称为 **虚拟内存**（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为 **虚拟地址空间**（virtual address space）。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随即访问存储器（DRAM），闪存，磁盘存储器，特殊硬件和操作系统结合起来，为程序提供一个看上去统一的字节数组。

* C语言中一个指针的值（无论它指向一个整数，一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。C编译器海拔每个指针和 **类型** 信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。
 
* 每台计算机都有一个 **字长** ，指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对一个字长为$w$位的机器而言，虚拟地址的范围为$0$~$2^{w}-1$，程序最多访问$2^w$个字节。（64位机器`sizeof(char *) //8`）

* 在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

* 在内存中按照从最低有效字节到最高有效字节的顺序存储对象，称为 **小端法**（little endian）。 在内存中按照从最高有效字节到最低有效字节的顺序存储对象，称为 **大端法** （big endian）

* 位向量就是固定长度为$w$，由0和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。

* 位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。

* 逻辑右移和算术右移。逻辑右移在左端补0，算术右移左端补最高有效位的值。

### 整数表示

* 在本节中，我们描述用位来编码整数的两种不同的形式：一种只能表示非负数，而另一种能够表示负数、零和整数。<br/>![]({{site_url}}/assets/csapp/ch2/2-8.png)

* C和C++都支持有符号（默认）和无符号数。Java只支持有符号数。

* **无符号数的编码**： 假设有一个整数数据有$w$位。我们可以将位向量写成$\vec{x}$，表示整个向量，或者写成$[x_{w-1},x_{w-2},...,x_0]$表示向量中的每一位。把$\vec{x}$看做一个二进制表示的数，就获得了$\vec{x}$的无符号表示。

* 我们用一个**函数$B2U_w$来将$\vec{x}$从二进制无符号数转化为十进制无符号数**，对向量$\vec{x}=[x_{w-1},x_{w-2},...,x_0]$:

$$
	B2U_w(\vec{x})=\sum_{i=0}^{w-1}x_i2^i
$$

* 无符号数编码的唯一性： 函数$B2U_w$是一个双射

* **补码编码**：最常见的有符号数的计算机表示方式就是**补码**（two's-complement）。在这个定义中，将字的最高有效位解释为**负权**。

* **补码编码的定义**，对向量$\vec{x}=[x_{w-1},x_{w-2},...,x_0]$:

$$
	B2T_w(\vec{x})=-x_{w-1}2^{w-1}+ \sum_{i=0}^{w-2}x_i2^i
$$

* 最高有效位$x_{w-1}$也成为符号位，它的权重为$-2^{w-1}$，是无符号表示中权重的负数。符号位被设置为1时，表示值为负，而当设置为0时，值为非负。

* 补码编码的唯一性： 函数$B2T_w$是一个双射。

* 下图是针对不同字长，几个重要数字的位模式和数值。<br/>![]({{site_url}}/assets/csapp/ch2/2-14.png)<br/>从图中可以看出，补码的范围是不对称的： $\|TMin\|=\|TMax\|+1$，也就是说，$TMin$没有与之对应的整数。之所以有这样的不对称性，是因为一半的位模式（符号位设置为1的数）表示负数，而另一半（符号位为0的数）表示非负数。因为0是非负数，也就意味着能表示的正数比负数少一个。最大的无符号数刚好比补码的最大值的两倍大1：$UMax_w=2TMax_w+1$。 补码表示中所有表示负数的位模式在无符号数中都变成了正数。

* 术语补码来源于这样一个情况，对于非负数x，我们用$2^w-x$来计算-x的w位表示。

* C语言允许强制类型转换，但是强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。
```
#include <stdio.h>
int main(){
    short int v=-12345;
    unsigned short uv=(unsigned short)v;
    printf("v=%d,uv=%u\n",v,uv);//v=-12345,uv=53191
    return 0;
}
```
* 可以发现-12345和53191的二进制位模式相同，因为$2^{16}-12345=53191$

* 定义函数$U2B_w$和$T2B_w$，它们将数值映射为无符号数和补码形式的位表示。也就是说，给定$0\leq{x}\leq{UMax_w}$范围内一个整数x，函数$U2B_w(x)$会给出x的唯一的w位无符号表示。相似地，当x满足$TMin_w \leq{x}\leq{TMax_w}$，函数$T2B_w(x)$会给出x的唯一的w位补码表示。

* 将函数$T2U_w$定义为$T2U_w(x)=B2U_w(T2B_w(x))$。这个函数的输入是$TMin_w$~$TMax_w$的数，结果得到一个$0$~$UMax_w$的值，这里两个数有相同的位模式。

* **$-x$的补码的位模式和$2^w-x$的无符号数的位模式相同**。因此计算一个负数补码的位模式，只要计算对应的无符号数的位模式即可。

* 补码转换位无符号数：
    * 对满足$TMin_w \leq {x} \leq {TMax_w}$的x有：
    
    $$
        T2Uw(x)=\begin{cases} x+2^w, x<0\\
                                x, x\geq{0}
                \end{cases}
    $$

* 无符号数转换为补码：
    * 对满足$0\leq{u}\leq {UMax_w}$的u有：
    
    $$
        U2T_w(u)=\begin{cases}
                    u, u\leq{TMax_w}\\
                    u-2^w, u>TMax_w
                \end{cases}
    $$

    * 映射区间如图所示：<br/>![]({{site_url}}/assets/csapp/ch2/2-18.png)
