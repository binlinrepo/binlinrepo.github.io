---
title: 处理器体系结构（4）
tags: CS-APP 处理器 x86-64
category: CS-APP
---

到目前为止，我们看到的计算机系统只限于机器语言程序级。我们知道处理器必须执行一系列指令，每条指令执行某个简单操作，例如两个数相加。指令被编码为有一个或多个字节序列组成的二进制格式。一个处理器支持的指令和指令的字节级编码称为他的**指令集体系结构**（Instruction-Set Architecture, ISA）。不同的处理器“家族”，例如Intel IA32和x86-64和ARM处理器家族，都有不同的ISA。

<!--more-->

## Y86-64指令集体系结构

定义一个指令集体系结构包括定义各种状态单元，指令集和它们的编码，一组编程规范和异常事件处理。

### 程序员可见的状态

![]({{site_url}}/assets/blog/csapp/ch4/4-1.png)
Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为**程序员可见状态**。

Y86-64的状态类似于x86-64。有15个**程序寄存器**：`%rax,%rcx,%rdx,%rbx,%rbp,%rsi,%rdi`和`%r8`到`%r14`。每个程序寄存器存储一个64位的字。寄存器%rsp被入栈，出栈，调用和返回指令作为栈指针。有3个1位的**条件码**：ZF，SF和OF，它们保存着最近的算术或逻辑指令所造成影响的有关信息。程序寄存器PC存放当前正在执行指令的地址。

内存从概念上来说就是一个字节数组，保存着程序和数据。Y86-64程序用虚拟地址引用内存位置。硬件和操作系统将虚拟地址翻译成实际的物理地址。

程序状态的最后一个部分是状态码Stat，它指明程序执行的总体状态。

### Y86-64指令

下图给出了Y86-64 ISA中各个指令的简单描述。Y86-64指令集基本上是x86-64指令集的一个子集。它只包括8字节整数操作。<br/>![]({{site_url}}/assets/blog/csapp/ch4/4-2.png)

Y86-64的movq指令分成了4个不同的指令：`irmovq,rrmovq,mrmovq,rmmovq`，分别显式地指明源和目的的格式。源可以是立即数i，寄存器r或内存m。指令的第一个字符就表明了源的类型。指令名字的第二个字符指明了目的的类型。**两个内存传送指令中的内存引用方式是简单的基址加偏移量形式**。

有4个整数操作指令，图中的Opq。它们是`addq,subq,andq,xorq`。它们只对寄存器数据进行操作。这些指令还会设置3个条件码ZF，SF和OF（零，符号和溢出）。

7个跳转指令是`jmp,jle,jl,je,jne,jge,jg`。根据分支指令的类型和条件代码的设置来选择分支。

有6个条件传送指令`cmovle,cmovl,cmove,cmovne,cmovge,cmovg`。这些指令的格式与寄存器-寄存器传送指令rrmovq一样，但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。

call指令将返回地址入栈，然后跳到目的地址。ret指令从这样的调用中返回。

pushq和popq指令实现了入栈和出栈。

halt指令停止指令的执行，并将状态码设置为HLT。

### 指令编码

上图还给出了指令的字节级编码。每条指令的第一个字节表明指令的类型。这个字节分为两部分，每部分4位：高4位是代码部分，低4位是功能部分。如上图所示，代码值位`0~0xB`。功能值只有在一组相关指令共用一个代码时才有用。<br/>![]({{site_url}}/assets/blog/csapp/ch4/4-3.png)

15个程序寄存器中每个都有一个相对应的范围在0到0xE之间的**寄存器标识符**。Y86-64中的寄存器编号和x86-64中的相同。程序寄存器在CPU的一个**寄存器文件**中，这个寄存器文件就是一个小的，以寄存器ID作为地址的随机访问存储器。

**指令集的一个重要性质就是字节编码必须有唯一的解释**。任何一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。
